## Соответствие групп и тем на практикум.

1. Что такое система контроля версий
2. Для чего нужна система контроля версий
3. Установка git на ваш ПК (в зависимости от системы)
4. Установка VSCode на ваш ПК
5. Что такое репозиторий и инструкция по созданию локальных репозиториев.
6. Базовая работа с локальным репозиторием
7. Что такое ветки и для чего они нужны при работе с системой контроля версий.
8. Базовая работа с ветками в git.
9. Что такое удаленный репозиторий и для чего он нужен
10. Базовая работа с удаленными репозиториями GitHub
11. Как строится и для чего нужна совместная работа в системах контроля версий
12. Инструкция по созданию pull request
13. Книги и полезные ссылки по изучению git.
14. Альтернативные системы контроля версий.

# **Инструкция по работе с Git.** 

>"Раньше люди думали: «Давайте закроем код, ведь мы на нем делаем деньги». Сейчас они понимают, что код нужно открыть, чтобы заработать еще больше денег."

>Крис Ванстрас (GitHub)

Данная инструкция рассчитана на человека, прежде не работавшего с системами контроля версий, однако, возможно, имеющего представление о том что такое командная строка.Здесь будут описаны только самые базовые операции, которыми необходимо владеть для успешной работы над научным проектом  ит.п..

Если у вас будут возникать какие-­либо вопросы — смело обращайтесь к кураторам проектов за разъяснениями и советами.

## **Краткое введение и терминология.**

Системы контроля версий, одной из которых является **Git**, используются при работе с самыми разными проектами, начиная от программных проектов и заканчивая написанием книги или статьи. При работе с документами мы часто пользуемся командами CTRL+S *(сохранить)* и CTRL+Z *(отменить)*, а если мы хотим сделать несколько вариантов, нам приходится сохранять каждый из них в отдельный файл, что не всегда удобно. **Git** же позволяет делать все то же самое, но не на уровне отдельного файла, а на уровне целого проекта. Каталог с проектом в этом случае называется репозиторием __*(repository)*__. Каждое такое глобальное CTRL+S называется коммитом **_(commit)_** и сохраняет текущую версию проекта, к которой всегда можно будет вернуться в любой момент (глобальный CTRL+Z). Также возможна работа с несколькими версиями, при этом не возникает множества файлов разных версий (на самом деле все изменения сохраняются в системной папке .git,находящейся в корне репозитория, и ее лучше не трогать). Кроме того __Git__ позволяет работать с несколькими копиями репозитория, беря на себя все проблемы, связанные с синхронизацией данных. Это не только предохраняет от потери данных, но и делает возможным эффективную командную работу над проектом.

### __Подготовка.__ 
1. **Регистрация на GitHub.** **GitHub** - это сервис для хранения репозиториев. Репозиторий научного проекта будет находиться именно там, поэтому если у вас еще нет аккаунта на __GitHub__, вам необходимо пройти стандартную процедуру регистрации.

2. Установить **Git** с официального сайта по инструкции: <http://git­scm.com/downloads>. Возможно, он уже есть у вас в системе — проверьте это, зайдя в командную строку и введя команду __*git*__.

3. Все команды **_git_** выполняются в терминале (командной строке). Пользователям Linux/MacOS для этого достаточно запустить Терминал. Пользователям Windows следует использовать утилиту **Git Bash** либо скачать и распаковать дистрибутив __Babun__ (осторожно, она весит 2Гб — зато полностью эмулирует работу в командной строке Linux).

4. Настройка **Git**. Нам будет достаточно только созадать имя и email командами:  
__*git config ­­global user.name*__ "Имя Фамилия",  
 **_git config ­­global user.email_** "электронная почта привязанная к учетной записи"  
 (вы, естественно,подставляете свои имя и email)  

Далее мы изучим основные операции на тестовом репозитории. Для начала нам понадобится завести репозиторий на **GitHub**.

### __Создание репозитория на GitHub.__

Для создания репозитория на **GitHub** нужно войти в систему, затем в навигационной панели сверху рядом с вашим именем выбрать **"+"** и __"New repository"__ (или на главной cтранице зеленая кнопка **"+ New repository"**). Далее заполняем поля:  
* *Repository name:* **test**  
* _Description:_ __Test repository__  
* оставляем выбранным пункт *"Public"* и проставляем флажок _"Initialize this repository with a README"_ 

Нажимаем кнопку **"Create repository"**. Репозиторий создан! 

Репозиторий, находящийся на **GitHub**, мы будем называть главным. При работе с научными проектами главный репозиторий уже будет создан руководителями.

#### __Базовые операции.__
**_1. Создание локальной копии главного репозитория._** Для начала нужно перейти в каталог, в котором вы хотите, чтобы появился каталог репозитория, и запустить в нем терминал. Для пользователей Linux/MacOS: запустить Терминал и с помощью команды cd перейти в нужный каталог. Для пользователей Windows: перейти в Проводнике в нужный каталог, щелкнуть правой кнопкой мыши в окне каталога и в контекстном меню выбрать пункт *"Git Bash"*.  
После запуска в терминале набрать команду:  
     **git clone** (_ссылка на главный репозиторий из GitHub_)  
В результате в текущем каталоге будет создан подкаталог **test**, содержащий копию главного репозитория. Для работы с репозиторием необходимо перейти в его каталог командой **cd test**.

**_2. Добавление новых файлов в репозиторий._** Давайте создадим в каталоге репозитория __test__ текстовый файл **first.txt**, содержащий строку текста _"Some text"_. Однако то, что файл появился в каталоге репозитория не означает, что **Git** его уже отслеживает - нужно указать это командой:  
     __*git add first.txt*__  
Теперь наш файл находится под наблюдением **Git**. Давайте сохраним изменения в репозитории и сделаем первый коммит:   
     **_git commit -­m "My first commit"_**  
Ключ **-­m** позволяет задать описание коммита. Описание обязательно, иначе коммит не будет выполнен. 
Теперь давайте создадим каталог **dir**, а в нем два текстовых файла __а.txt__ и __b.txt__. Чтобы при добавлении в **Git** не перечислять их по отдельности, воспользуемся командой:  
     **_git add_**  
которая добавляет в **Git** все новые файлы. И снова сохраним:  
     __*git commit ­-m "dir added"*__

**_3. Сохранение изменений файлов._** Добавим в файл **first.txt** еще одну строчку *"Some more text"* (не забудьте сохранить файл!). И снова закоммитим изменения. Однако если мы воспользуемся известной нам командой:  
     __*git commit ­m "more text added to first.txt"*__  
то мы получим сообщение, что коммитить в общем­то нечего. *Почему?* Дело в том, что **Git** опять же не знает, какие именно из измененных файлов мы хотим сохранить. Чтобы указать это, необходимо воспользоваться описанной выше командой:  
     __*git add*__  
В то же время самый частый сценарий ­ сохранить изменения во всех файлах. Для этих целей в команде: __*git commit*__ есть ключик **-­a**.

Итого наша команда будет такой:  
     __*git commit ­-a -­m "more text added to first.txt"*__

Чтобы меньше запоминать, вам будет достаточно для всех коммитов пользоваться командой именно такого вида.  
Однако помните, что ключ **-­a** позволяет учесть изменения только в файлах, уже находящихся под наблюдением **Git**. А новые файлы перед коммитом необходимо предварительно добавить командой: __*git add*__ (про нее вам рассказали не просто так).

**_4. Отправка изменений в главный репозиторий._** К этому моменту мы уже немало сделали в нашей локальной копии репозитория, однако если вы обновите веб­страничку с главным репозиторием, вы увидите, что в нем никаких изменений нет. *Как их туда внести?* Для этого используется команда:  
     __*git push*__  
В процессе выполнения команды от вас потребуется ввести ваши логин и пароль от аккаунта на **GitHub**. Когда после успешного завершения команды мы обновим страничку с главным репозиторием, мы увидим, что теперь его содержимое совпадает с нашим локальным репозиторием.

**_5. Получение изменений из главного репозитория._** Смоделируем ситуацию, в которой нам это пригодится. Для этого откроем еще один терминал в каталоге, отличном от того, в котором лежит наш локальный репозиторий. И создадим еще одну локальную копию главного репозитория (как ­ описано выше). Итого у нас теперь есть два локальных репозитория: __*первый (старый)*__ и __*второй (только что созданный)*__. Представим, что второй репозиторий на самом деле находится на другом компьютере и с ним работает второй участник. И он решает внести какие­то изменения в файл **first.txt** (например, добавим туда еще одну строчку текста), находящийся в его локальной копии, т.е. во втором репозитории.Сохраняем файл и коммитим:  
     __*git commit -­a -­m "more changes in first.txt"*__  
а затем отправляем изменения на сервер командой:  
     __*git push*__  
Сейчас у нас синхронизированы главный и второй локальный репозитории, но первый локальный отстает. Ему нужно получить изменения из главного репозитория командой:  
     __*git pull*__  
Ура, теперь у нас везде одинаковые версии.

**_6. Разрешение конфликтов._** В заключение рассмотрим еще один частый сценарий, распространенный при одновременной работе нескольких человек. Давайте в нашем первом локальном репозитории внесем еще какие­нибудь изменения в файл **first.txt**, закоммитим и отправим их в главный репозиторий. А затем во втором локальном репозитории создадим файл __second.txt__ и тоже закоммитим. Однако если теперь из второго репозитория мы попробуем сделать __*git push*__, то получим ошибку из­-за конфликта изменений. *Почему?* Для простоты можно считать, что при отправке изменений в локальном репозитории должна быть версия, основанная на версии главного репозитория. Тогда как мы во втором репозитории пока ничего не знаем про последний коммит **first.txt**. *Что делать?* Сначала нам нужно получить изменения из главного репозитория, затем объединить их с нашими изменениями, и то, что получилось, отправить на главный репозиторий. Звучит непросто, но на самом деле первые два шага сама умеет делать команда **_git pull_**. Она достаточно умна, чтобы понять, что в нашем случае надо обновить файл __first.txt__ и добавить __second.txt__. После чего нам остается просто отправить изменения командой __*git push*__. Итого получаем, что при отправке изменений безопасно пользоваться двумя последовательными командами:  
     __*git pull*__ (проверить на наличие новых изменений в репозитории и, если они есть, выкачать их и объединить с локальными изменениями)  
     __*git push*__ (отправить изменения в репозиторий)

Таким образом, **Git** умеет разрешать конфликты самостоятельно. Но к сожалению не все. Если бы мы вместо создания **second.txt** во втором репозитории тоже изменили **first.txt**, то мы бы имели две измененные версии одного файла и здесь уже **Git** самостоятельно разрешить конфликт не может: нужно вмешательство человека. При грамотно спланированной работе команды, такие ситуации встречаются редко, и мы их рассматривать не будем. Интересующиеся могут
посмотреть в интернете или в справке **Git** по команде __*merge*__ в разделе **"How to   
resolve conflicts"**.

### __Итоговая сводка команд.__ 

1. Создание локальной копии главного репозитория:  
     __*git clone (ссылка на главный репозитории из GitHub)*__  
     __*cd test*__ (не забыть перейти в каталог репозитория)

2. Добавление новых файлов в репозиторий.  
Избранные файлы:  
     __*git add file1 file2 file3*__  
Все новые файлы:  
     __*git add*__

3. Сохранение изменений файлов:  
     __*git commit ­am "commit description"*__

4. Получение изменений из главного репозитория:  
     __*git pull*__

5. Отправка изменений в главный репозиторий (с авторазрешением конфликтов):  
     __*git pull*__ (проверить на наличие новых изменений в репозитории и, если они есть, выкачать их и объединить с локальными изменениями)  
     __*git push*__ (отправить изменения в репозиторий)

### __Рекомендации по ведению репозитория.__ 

1. Давать коммитам осмысленные описания: *"Report of sequences quality added"* или *"Fixed bug with division by 0 in function foo()"*.

2. Делать атомарные коммиты, т.е. те, которые можно описать одной фразой **(см.п.1)**, а не перечнем из нескольких пунктов. При этом фразы вроде *"Many different changes"* не годятся. Фанатизма тоже не надо. Если вы решили **_"причесать"_** код (отформатировать, переименовать функции и переменные и т.п.), то такие изменения, естественно, надо коммитить не по одному, а все сразу с пометкой *"Refactoring"*.

3. Планируйте работу в команде так, чтобы несколько человек не редактировали одновремено одинаковые файлы. Это убережет вас от разрешения конфликтов вручную. Если вам действительно необходима одновременная работа нескольких человек, используйте для этого соответствующие средства, например Google Документы.

4. Сразу отправляйте коммиты в главный репозиторий. Тогда у всех участников будет актуальная версия проекта и это также поможет вам избежать конфликтов.

## **Для тех, кто хочет большего.**

Для того чтобы больше узнать о других командах, функциях и возможностях **Git**, таких как:  
     __*git init*__ (привязка репозитория к **Git**)  
     __*git status*__ (информация о статусе репозитория)  
     __*git log*__ (журнал изменений)  
     __*git checkout*__ (переключение между закомиченными версиями(изменениями))  
     __*git diff*__ (сравнение сохраненых данных)  
     __*git branch*__ (список существующих веток)  
     __*git branch "название ветки"*__ (создание новой ветки)  
     __*git checkout "название ветки"*__ (переход между ветками)  
     __*git merge "название ветки"*__ (слияние второстепенной ветки в основную ветвь)  
     __*git branch -d "название ветки"*__ (удаление не нужной ветки)  
     __*git log --graph*__ (структура веток(дерево))  

А также о создание файла **_.gitignore_** (для изображений), о командах __*git clone (ссылка на репозиторий)*__ / __*git remote add (ссылка на репозиторий)*__, о функциях **FORK** (понятие форкнуть), о создании конфликтов при слиянии различных веток и о их исправлениях, о принятии решений по данным конфликтам и о многом другом в данной системе контроля версий.

Вам всего лишь надо поступить в **GEEK BRAINS** <https://gb.ru/>, и под руководством профессионалов познать мир **IT**.

Ну или или выбрать путь сложнее и разобраться во всем самому. В интернете без труда можно найти руководства и туториалы, рассчитанные на разные уровни подготовки. 

Приводим некоторые из них:  
1. Интерактивные туториалы:  
* <http://githowto.com/ru>  
* <https://try.github.io>  
* <http://pcottle.github.io/learnGitBranching/>

2. Руководства для начинающих:  
* <http://ruseller.com/lessons.php?rub=28&id=2035>  
* <http://hexvolt.blogspot.ru/2014/01/git­1.html>  
* <http://cluster.krc.karelia.ru/doc/rukovodstvo_GIT.pdf>  
* <http://htmlstudio.ru/git­для­начинающих­краткое­руков> 